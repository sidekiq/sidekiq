#!/usr/bin/env ruby

require 'bundler/inline'

gemfile do
  source 'https://gem.coop'
  gem "ratatui_ruby", "0.9.1"
  gem "sidekiq"
end

# https://sr.ht/~kerrick/ratatui_ruby/
# https://git.sr.ht/~kerrick/ratatui_ruby/tree/stable/item/examples/
require "ratatui_ruby"
require "sidekiq/api"

# Suppress Sidekiq logger output to prevent interference with TUI rendering
require "logger"
Sidekiq.default_configuration.logger = Logger.new(IO::NULL)

module Sidekiq
  class TUI
    REFRESH_INTERVAL_SECONDS = 5

    TABS = %w(Home Busy Queues Scheduled Retries Dead).freeze

    def initialize
      @current_tab = "Home"
      @base_style = nil
      @home_data = nil
      @last_refresh = Time.now

      stats = Sidekiq::Stats.new
      @realtime_chart = {
        previous_stats: {
          processed: stats.processed,
          failed: stats.failed
        },
        deltas: {
          processed: Array.new(50, 0),
          failed: Array.new(50, 0)
        }
      }
    end

    def run
      RatatuiRuby.run do |tui|
        @tui = tui
        @highlight_style = @tui.style(fg: :red, modifiers: [:underlined])
        @hotkey_style = @tui.style(modifiers: [:bold, :underlined])

        refresh_data

        loop do
          refresh_data if should_refresh?
          render
          break if handle_input == :quit
        end
      end
    end

    def render
      @tui.draw do |frame|
        main_area, controls_area = @tui.layout_split(
          frame.area,
          direction: :vertical,
          constraints: [
            @tui.constraint_fill(1),
            @tui.constraint_length(4),
          ]
        )

        # Split main area into tabs and content
        tabs_area, content_area = @tui.layout_split(
          main_area,
          direction: :vertical,
          constraints: [
            @tui.constraint_length(3),
            @tui.constraint_fill(1),
          ]
        )

        tabs = @tui.tabs(
          titles: TABS,
          selected_index: selected_tab_index,
          block: @tui.block(title: Sidekiq::NAME, borders: [:all], title_style: @tui.style(fg: :red, modifiers: [:bold])),
          divider: " | ",
          highlight_style: @highlight_style,
          style: @base_style,
        )
        frame.render_widget(tabs, tabs_area)

        render_content_area(frame, content_area)
        render_controls(frame, controls_area, tabs.width)
      end
    end

    def render_content_area(frame, content_area)
      case @current_tab
      when "Home"
        render_home(frame, content_area)
      when "Busy"
        render_busy(frame, content_area)
      when "Queues"
        render_queues(frame, content_area)
      when "Scheduled"
        render_set(frame, content_area, Sidekiq::ScheduledSet.new)
      when "Retries"
        render_set(frame, content_area, Sidekiq::RetrySet.new)
      when "Dead"
        render_set(frame, content_area, Sidekiq::DeadSet.new)
      else
        frame.render_widget(
          @tui.paragraph(
            text: "Tab '#{@current_tab}' - Coming soon",
            alignment: :center,
            block: @tui.block(title: @current_tab, borders: [:all])
          ),
          content_area
        )
      end
    end

    def render_controls(frame, area, current_width)
      controls = @tui.block(
        title: "Controls",
        borders: [:all],
        children: [
          @tui.paragraph(
            text: [
              @tui.text_line(spans: [
                @tui.text_span(content: "←/→", style: @hotkey_style),
                @tui.text_span(content: ": Select Tab  "),
                @tui.text_span(content: "q", style: @hotkey_style),
                @tui.text_span(content: ": Quit"),
              ]),
              # @tui.text_line(spans: [
              #   @tui.text_span(content: "d", style: @hotkey_style),
              #   @tui.text_span(content: ": Divider (#{@dividers[@divider_index]})  "),
              #   @tui.text_span(content: "s", style: @hotkey_style),
              #   @tui.text_span(content: ": Highlight (#{@highlight_styles[@highlight_style_index][:name]})  "),
              #   @tui.text_span(content: "b", style: @hotkey_style),
              #   @tui.text_span(content: ": Base Style (#{@base_styles[@base_style_index][:name]})  "),
              # ]),
              @tui.text_line(spans: [
                @tui.text_span(content: "Redis: #{redis_url}"),
              ]),
            ]
          ),
        ]
      )
      frame.render_widget(controls, area)
    end

    def handle_input
      case @tui.poll_event
      in { type: :key, code: "q" } | { type: :key, code: "c", modifiers: ["ctrl"] }
        :quit
      in type: :key, code: "right"
        @current_tab = next_tab
        refresh_data if @current_tab == "Home"
      in type: :key, code: "left"
        @current_tab = previous_tab
        refresh_data if @current_tab == "Home"
      else
        # Ignore other events
      end
    end

    def redis_url
      Sidekiq.redis do |conn|
        conn.config.server_url
      end
    rescue
      "N/A"
    end

    def should_refresh?
      Time.now - @last_refresh >= REFRESH_INTERVAL_SECONDS
    end

    def selected_tab_index
      TABS.index(@current_tab) || 0
    end

    def next_tab
      current_index = selected_tab_index
      TABS[(current_index + 1) % TABS.size]
    end

    def previous_tab
      current_index = selected_tab_index
      TABS[(current_index - 1) % TABS.size]
    end

    def refresh_data
      return unless @current_tab == "Home"

      stats = Sidekiq::Stats.new
      redis_info = Sidekiq.default_configuration.redis_info

      processed_delta = stats.processed - @realtime_chart[:previous_stats][:processed]
      failed_delta = stats.failed - @realtime_chart[:previous_stats][:failed]
      @realtime_chart[:deltas][:processed].shift
      @realtime_chart[:deltas][:processed].push(processed_delta)
      @realtime_chart[:deltas][:failed].shift
      @realtime_chart[:deltas][:failed].push(failed_delta)

      @realtime_chart[:previous_stats] = {
        processed: stats.processed,
        failed: stats.failed
      }

      @home_data = {
        stats: {
          processed: stats.processed,
          failed: stats.failed,
          busy: stats.workers_size,
          enqueued: stats.enqueued,
          retries: stats.retry_size,
          scheduled: stats.scheduled_size,
          dead: stats.dead_size,
        },
        redis_info: {
          version: redis_info["redis_version"] || "N/A",
          uptime_days: redis_info["uptime_in_days"] || "N/A",
          connected_clients: redis_info["connected_clients"] || "N/A",
          used_memory: redis_info["used_memory_human"] || "N/A",
          peak_memory: redis_info["used_memory_peak_human"] || "N/A"
        }
      }
      @last_refresh = Time.now
    rescue => e
      @home_data = { error: e.message }
    end

    def render_busy(frame, area)
      chunks = @tui.layout_split(
        area,
        direction: :vertical,
        constraints: [
          @tui.constraint_length(4), # Stats
          @tui.constraint_length(4), # Status
          @tui.constraint_fill(1),   # Graph
        ]
      )

      render_stats_section(frame, chunks[0])
      render_status_section(frame, chunks[1])
      render_table(frame, chunks[2]) do
        {
          title: "Processes",
          header: ["Name", "Started", "RSS", "Threads", "Busy"],
          widths: [
            @tui.constraint_length(40),
            @tui.constraint_length(16),
            @tui.constraint_length(10),
            @tui.constraint_length(6),
            @tui.constraint_length(6),
          ],
        # footer: ["Total: #{PROCESSES.length}", "Total CPU: #{PROCESSES.sum { |p| p[:cpu] }}%", ""]
        }.tap do |h|
          rows = []
          Sidekiq::ProcessSet.new.each_with_index {|p, idx|
            rows << @tui.table_row(
              cells: [
                "#{p["hostname"]}:#{p["pid"]}",
                Time.at(p['started_at']).utc.iso8601,
                format_memory(p['rss'].to_i),
                number_with_delimiter(p['concurrency']),
                number_with_delimiter(p['busy'])],
              style: idx.even? ? nil : @tui.style(bg: :dark_gray))
          }
          h[:rows] = rows
          h
        end
      end
    end

    def render_set(frame, area, set)
      chunks = @tui.layout_split(
        area,
        direction: :vertical,
        constraints: [
          @tui.constraint_length(4), # Stats
          @tui.constraint_fill(1),   # Table
        ]
      )

      render_stats_section(frame, chunks[0])
      render_table(frame, chunks[1]) do
        {
          title: set.name,
          header: ["When", "Queue", "Job", "Arguments", "Actions"],
          widths: [
            @tui.constraint_length(20),
            @tui.constraint_length(16),
            @tui.constraint_length(20),
            @tui.constraint_length(24),
            @tui.constraint_length(20),
          ],
        }.tap do |h|
          rows = set.map.with_index {|p, idx|
            @tui.table_row(
              cells: [
                p.at,
                p.queue,
                p.display_class,
                p.display_args,
                "TODO"],
              style: idx.even? ? nil : @tui.style(bg: :dark_gray))
          }
          h[:rows] = rows
          h
        end
      end
    end

    def render_home(frame, area)
      return render_error(frame, area, "Loading...") unless @home_data
      return render_error(frame, area, "Error: #{@home_data[:error]}") if @home_data[:error]

      chunks = @tui.layout_split(
        area,
        direction: :vertical,
        constraints: [
          @tui.constraint_length(4), # Stats
          @tui.constraint_fill(1),   # Graph
          @tui.constraint_length(4), # Redis
        ]
      )

      render_stats_section(frame, chunks[0])
      render_chart_section(frame, chunks[1])
      render_redis_info_section(frame, chunks[2])
    end

    def render_status_section(frame, area)
      keys = ["Processes", "Threads", "Busy", "Utilization", "RSS"]
      values = []
      processes = Sidekiq::ProcessSet.new
      workset = Sidekiq::WorkSet.new
      ws = workset.size
      values << (s = processes.size; number_with_delimiter(s))
      values << (x = processes.total_concurrency; number_with_delimiter(x))
      values << number_with_delimiter(ws)
      values << "#{x == 0 ? 0 : ((ws / x.to_f) * 100).round(0)}%"
      values << format_memory(processes.total_rss)

      keys_line = keys.map { |k| k.to_s.ljust(12) }.join("  ")
      values_line = values.map { |v| v.to_s.ljust(12) }.join("  ")

      frame.render_widget(
        @tui.paragraph(
          text: [keys_line, values_line],
          block: @tui.block(title: "Status", borders: [:all])
        ),
        area
      )
    end

    def render_stats_section(frame, area)
      stats = @home_data[:stats]

      keys = ["Processed", "Failed", "Busy", "Enqueued", "Retries", "Scheduled", "Dead"]
      values = [
        stats[:processed],
        stats[:failed],
        stats[:busy],
        stats[:enqueued],
        stats[:retries],
        stats[:scheduled],
        stats[:dead],
      ]

      # Format keys and values with spacing
      keys_line = keys.map { |k| k.to_s.ljust(12) }.join("  ")
      values_line = values.map { |v| v.to_s.ljust(12) }.join("  ")

      frame.render_widget(
        @tui.paragraph(
          text: [keys_line, values_line],
          block: @tui.block(title: "Statistics", borders: [:all])
        ),
        area
      )
    end

    def render_chart_section(frame, area)
      max_value = [@realtime_chart[:deltas][:processed].max, @realtime_chart[:deltas][:failed].max, 1].max
      y_max = [max_value, 5].max

      processed_data = @realtime_chart[:deltas][:processed].each_with_index.map { |value, idx| [idx.to_f, value.to_f] }
      failed_data = @realtime_chart[:deltas][:failed].each_with_index.map { |value, idx| [idx.to_f, value.to_f] }

      datasets = [
        @tui.dataset(
          name: "",
          data: processed_data,
          style: @tui.style(fg: :green),
          marker: :dot,
          graph_type: :line
        ),
        @tui.dataset(
          name: "",
          data: failed_data,
          style: @tui.style(fg: :red),
          marker: :dot,
          graph_type: :line
        )
      ]

      num_labels = 5
      y_labels = (0...num_labels).map do |i|
        value = ((y_max * i) / (num_labels - 1)).round
        value.to_s
      end

      beacon_pulse = (Time.now.to_i % 2 == 0) ? "●" : " "

      chart = @tui.chart(
        datasets: datasets,
        x_axis: @tui.axis(
          bounds: [0.0, 49.0],
          labels: [],
          style: @tui.style(fg: :white)
        ),
        y_axis: @tui.axis(
          bounds: [0.0, y_max.to_f],
          labels: y_labels,
          style: @tui.style(fg: :white)
        ),
        block: @tui.block(
          title: "Dashboard #{beacon_pulse}",
          borders: [:all],
        )
      )

      frame.render_widget(chart, area)
    end

    def render_redis_info_section(frame, area)
      redis_info = @home_data[:redis_info]

      uptime_value = redis_info[:uptime_days] == "N/A" ? "N/A" : "#{redis_info[:uptime_days]} days"

      keys = ["Version", "Uptime", "Connected Clients", "Memory Usage", "Peak Memory"]
      values = [
        redis_info[:version].to_s,
        uptime_value,
        redis_info[:connected_clients].to_s,
        redis_info[:used_memory].to_s,
        redis_info[:peak_memory].to_s
      ]

      # Format keys and values with spacing
      keys_line = keys.map { |k| k.ljust(18) }.join("  ")
      values_line = values.map { |v| v.ljust(18) }.join("  ")

      frame.render_widget(
        @tui.paragraph(
          text: [keys_line, values_line],
          block: @tui.block(title: "Redis Information", borders: [:all])
        ),
        area
      )
    end

    def render_queues(frame, area)
      chunks = @tui.layout_split(
        area,
        direction: :vertical,
        constraints: [
          @tui.constraint_length(4), # Stats
          @tui.constraint_fill(1), # Table
        ]
      )

      render_stats_section(frame, chunks[0])
      render_table(frame, chunks[1]) do
        {
          title: "Queues",
          header: ["Queue", "Size", "Latency", "Actions"],
          widths: [
            @tui.constraint_length(60),
            @tui.constraint_length(10),
            @tui.constraint_length(10),
            @tui.constraint_length(10),
          ],
          rows: Sidekiq::Stats.new
            .queues_with_latency
            .sort_by(&:first) # sort by queue name
            .map.with_index { |(name, size, latency), idx|
              @tui.table_row(
                cells: [
                  name,
                  size.to_s,
                  number_with_delimiter(latency, { precision: 2 }),
                  "TODO" # TODO: placeholder for actions; see lib/sidekiq/web/application.rb:137
                ],
                style: idx.even? ? nil : @tui.style(bg: :dark_gray)
              )
            }
        }
      end
    end

    def render_error(frame, area, message)
      frame.render_widget(
        @tui.paragraph(
          text: message,
          alignment: :center,
          block: @tui.block(title: "Error", borders: [:all], border_style: @tui.style(fg: :red))
        ),
        area
      )
    end

    # TODO Implement I18n delimiter
    def number_with_delimiter(number, options = {})
      precision = options[:precision] || 0
      number.round(precision)
    end

    def format_memory(rss_kb)
      return "0" if rss_kb.nil? || rss_kb == 0

      if rss_kb < 100_000
        "#{number_with_delimiter(rss_kb)} KB"
      elsif rss_kb < 10_000_000
        "#{number_with_delimiter((rss_kb / 1024.0).to_i)} MB"
      else
        "#{number_with_delimiter(rss_kb / (1024.0 * 1024.0), precision: 1)} GB"
      end
    end

    def render_table(frame, area)
      defaults = {
        title: "TableName",
        highlight_symbol: "> ",
        selected_row: 0,
        row_highlight_style: @tui.style(fg: :yellow),
      }
      hash = defaults.merge(yield)
      hash[:block] ||= @tui.block(title: hash.delete(:title), borders: :all)
      table = @tui.table(**hash)
      frame.render_widget(table, area)
    end
  end
end

Sidekiq::TUI.new.run
