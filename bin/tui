#!/usr/bin/env ruby

require 'bundler/inline'

gemfile do
  source 'https://gem.coop'
  gem "ratatui_ruby", "0.9.1"
  gem "sidekiq"
end

# https://sr.ht/~kerrick/ratatui_ruby/
# https://git.sr.ht/~kerrick/ratatui_ruby/tree/stable/item/examples/
require "ratatui_ruby"
require "sidekiq/api"

# Suppress Sidekiq logger output to prevent interference with TUI rendering
require "logger"
Sidekiq.default_configuration.logger = Logger.new(IO::NULL)

module Sidekiq
  class TUI
    REFRESH_INTERVAL_SECONDS = 5

    TABS = %w(Home Busy Queues Scheduled Retries Dead).freeze
    # CONTROLS defines data for input handling and for displaying controls.
    # :code is the key code for input handling.
    # :display and :description are shown in the controls area, with different
    #   styling between them. If :display is omitted, :code is displayed instead.
    #   Duplicate :display and :description values are ignored, shown only once.
    # :tabs is an array of tab names where the control is active.
    # :action is a lambda to execute when the control is triggered.
    CONTROLS = [
      { code: "left", display: "←/→", description: "Select Tab", tabs: TABS,
        action: ->(tui) { tui.navigate_tab(:left) }
      },
      { code: "right", display: "←/→", description: "Select Tab", tabs: TABS,
        action: ->(tui) { tui.navigate_tab(:right) }
      },
      { code: "up", display: "↑/↓", description: "Select Row", tabs: TABS - ["Home"],
        action: ->(tui) { tui.navigate_row(:up) }
      },
      { code: "down", display: "↑/↓", description: "Select Row", tabs: TABS - ["Home"],
        action: ->(tui) { tui.navigate_row(:down) }
      },
      { code: "d", description: "Delete Queue", tabs: ["Queues"],
        action: ->(tui) { tui.delete_queue! }
      },
      { code: "p", description: "Pause/Unpause Queue", tabs: ["Queues"],
        action: ->(tui) { tui.toggle_pause_queue! }
      },
      { code: "q", display: "q", description: "Quit", tabs: TABS,
        action: ->(tui) { :quit }
      },
      { code: "c", modifiers: ["ctrl"], display: "q", description: "Quit", tabs: TABS,
        action: ->(tui) { :quit }
      }
    ].freeze

    def initialize
      @current_tab = "Home"
      @selected_row_index = 0
      @table_row_ids = [] # containing the identifier of each row, e.g. queue name
      @base_style = nil
      @home_data = nil
      @last_refresh = Time.now

      stats = Sidekiq::Stats.new
      @realtime_chart = {
        previous_stats: {
          processed: stats.processed,
          failed: stats.failed
        },
        deltas: {
          processed: Array.new(50, 0),
          failed: Array.new(50, 0)
        }
      }
    end

    def run
      RatatuiRuby.run do |tui|
        @tui = tui
        @highlight_style = @tui.style(fg: :red, modifiers: [:underlined])
        @hotkey_style = @tui.style(modifiers: [:bold, :underlined])

        refresh_data

        loop do
          refresh_data if should_refresh?
          render
          break if handle_input == :quit
        end
      end
    end

    def render
      @tui.draw do |frame|
        main_area, controls_area = @tui.layout_split(
          frame.area,
          direction: :vertical,
          constraints: [
            @tui.constraint_fill(1),
            @tui.constraint_length(4),
          ]
        )

        # Split main area into tabs and content
        tabs_area, content_area = @tui.layout_split(
          main_area,
          direction: :vertical,
          constraints: [
            @tui.constraint_length(3),
            @tui.constraint_fill(1),
          ]
        )

        tabs = @tui.tabs(
          titles: TABS,
          selected_index: TABS.index(@current_tab),
          block: @tui.block(title: Sidekiq::NAME, borders: [:all], title_style: @tui.style(fg: :red, modifiers: [:bold])),
          divider: " | ",
          highlight_style: @highlight_style,
          style: @base_style,
        )
        frame.render_widget(tabs, tabs_area)

        render_content_area(frame, content_area)
        render_controls(frame, controls_area, tabs.width)
      end
    end

    def render_content_area(frame, content_area)
      case @current_tab
      when "Home"
        render_home(frame, content_area)
      when "Busy"
        render_busy(frame, content_area)
      when "Queues"
        render_queues(frame, content_area)
      when "Scheduled"
        render_set(frame, content_area, Sidekiq::ScheduledSet.new)
      when "Retries"
        render_set(frame, content_area, Sidekiq::RetrySet.new)
      when "Dead"
        render_set(frame, content_area, Sidekiq::DeadSet.new)
      else
        frame.render_widget(
          @tui.paragraph(
            text: "Tab '#{@current_tab}' - Coming soon",
            alignment: :center,
            block: @tui.block(title: @current_tab, borders: [:all])
          ),
          content_area
        )
      end
    end

    def render_controls(frame, area, current_width)
      keys_and_descriptions = CONTROLS
        .select { |ctrl|
          ctrl[:tabs].include?(@current_tab)
        }.map { |ctrl|
          [ctrl[:display] || ctrl[:code], ctrl[:description]]
        }.to_h

      controls = @tui.block(
        title: "Controls",
        borders: [:all],
        children: [
          @tui.paragraph(
            text: [
              @tui.text_line(spans: keys_and_descriptions.map { |key, desc|
                [
                  @tui.text_span(content: key, style: @hotkey_style),
                  @tui.text_span(content: ": #{desc}  ")
                ]
              }.flatten),
              # @tui.text_line(spans: [
              #   @tui.text_span(content: "d", style: @hotkey_style),
              #   @tui.text_span(content: ": Divider (#{@dividers[@divider_index]})  "),
              #   @tui.text_span(content: "s", style: @hotkey_style),
              #   @tui.text_span(content: ": Highlight (#{@highlight_styles[@highlight_style_index][:name]})  "),
              #   @tui.text_span(content: "b", style: @hotkey_style),
              #   @tui.text_span(content: ": Base Style (#{@base_styles[@base_style_index][:name]})  "),
              # ]),
              @tui.text_line(spans: [
                @tui.text_span(content: "Redis: #{redis_url}"),
              ]),
            ]
          ),
        ]
      )
      frame.render_widget(controls, area)
    end

    def handle_input
      case @tui.poll_event
      in { type: :key, code:, modifiers: }
        control = CONTROLS.find { |ctrl|
          ctrl[:code] == code &&
          (ctrl[:modifiers] || []) == (modifiers || []) &&
          ctrl[:tabs].include?(@current_tab)
        }
        return unless control
        control[:action].call(self)
      else
        # Ignore other events
      end
    end

    # Navigate tabs to the left or right.
    # @param direction [Symbol] :left or :right
    def navigate_tab(direction)
      index_change = direction == :right ? 1 : -1
      @current_tab = TABS[(TABS.index(@current_tab) + index_change) % TABS.size]
      @selected_row_index = 0
      refresh_data if @current_tab == "Home"
    end

    # Navigate the row selection up or down in the current tab's table.
    # @param direction [Symbol] :up or :down
    def navigate_row(direction)
      return if @table_row_ids.empty?

      index_change = direction == :down ? 1 : -1
      @selected_row_index = (@selected_row_index + index_change) % @table_row_ids.count
    end

    def delete_queue!
      return if @table_row_ids.empty?

      queue_name = @table_row_ids[@selected_row_index]
      Sidekiq::Queue.new(queue_name).clear
    end

    def toggle_pause_queue!
      return if @table_row_ids.empty?
      return unless Sidekiq.pro?

      queue_name = @table_row_ids[@selected_row_index]
      queue = Sidekiq::Queue.new(queue_name)
      if queue.paused?
        queue.unpause!
      else
        queue.pause!
      end
    end

    def redis_url
      Sidekiq.redis do |conn|
        conn.config.server_url
      end
    rescue
      "N/A"
    end

    def should_refresh?
      Time.now - @last_refresh >= REFRESH_INTERVAL_SECONDS
    end

    def refresh_data
      return unless @current_tab == "Home"

      stats = Sidekiq::Stats.new
      redis_info = Sidekiq.default_configuration.redis_info

      processed_delta = stats.processed - @realtime_chart[:previous_stats][:processed]
      failed_delta = stats.failed - @realtime_chart[:previous_stats][:failed]
      @realtime_chart[:deltas][:processed].shift
      @realtime_chart[:deltas][:processed].push(processed_delta)
      @realtime_chart[:deltas][:failed].shift
      @realtime_chart[:deltas][:failed].push(failed_delta)

      @realtime_chart[:previous_stats] = {
        processed: stats.processed,
        failed: stats.failed
      }

      @home_data = {
        stats: {
          processed: stats.processed,
          failed: stats.failed,
          busy: stats.workers_size,
          enqueued: stats.enqueued,
          retries: stats.retry_size,
          scheduled: stats.scheduled_size,
          dead: stats.dead_size,
        },
        redis_info: {
          version: redis_info["redis_version"] || "N/A",
          uptime_days: redis_info["uptime_in_days"] || "N/A",
          connected_clients: redis_info["connected_clients"] || "N/A",
          used_memory: redis_info["used_memory_human"] || "N/A",
          peak_memory: redis_info["used_memory_peak_human"] || "N/A"
        }
      }
      @last_refresh = Time.now
    rescue => e
      @home_data = { error: e.message }
    end

    def render_busy(frame, area)
      chunks = @tui.layout_split(
        area,
        direction: :vertical,
        constraints: [
          @tui.constraint_length(4), # Stats
          @tui.constraint_length(4), # Status
          @tui.constraint_fill(1),   # Graph
        ]
      )

      render_stats_section(frame, chunks[0])
      render_status_section(frame, chunks[1])
      render_table(frame, chunks[2]) do
        {
          title: "Processes",
          header: ["Name", "Started", "RSS", "Threads", "Busy"],
          widths: [
            @tui.constraint_length(40),
            @tui.constraint_length(16),
            @tui.constraint_length(10),
            @tui.constraint_length(6),
            @tui.constraint_length(6),
          ],
        # footer: ["Total: #{PROCESSES.length}", "Total CPU: #{PROCESSES.sum { |p| p[:cpu] }}%", ""]
        }.tap do |h|
          rows = []
          Sidekiq::ProcessSet.new.each_with_index {|p, idx|
            rows << @tui.table_row(
              cells: [
                "#{p["hostname"]}:#{p["pid"]}",
                Time.at(p['started_at']).utc.iso8601,
                format_memory(p['rss'].to_i),
                number_with_delimiter(p['concurrency']),
                number_with_delimiter(p['busy'])],
              style: idx.even? ? nil : @tui.style(bg: :dark_gray))
          }
          h[:rows] = rows
          h
        end
      end
    end

    def render_set(frame, area, set)
      @table_row_ids = set.map { |job| [job.score, job["jid"]] }

      chunks = @tui.layout_split(
        area,
        direction: :vertical,
        constraints: [
          @tui.constraint_length(4), # Stats
          @tui.constraint_fill(1),   # Table
        ]
      )

      render_stats_section(frame, chunks[0])
      render_table(frame, chunks[1]) do
        {
          title: set.name,
          header: ["When", "Queue", "Job", "Arguments", "Actions"],
          widths: [
            @tui.constraint_length(20),
            @tui.constraint_length(16),
            @tui.constraint_length(20),
            @tui.constraint_length(24),
            @tui.constraint_length(20),
          ],
        }.tap do |h|
          rows = set.map.with_index {|p, idx|
            @tui.table_row(
              cells: [
                p.at,
                p.queue,
                p.display_class,
                p.display_args,
                "TODO"],
              style: idx.even? ? nil : @tui.style(bg: :dark_gray))
          }
          h[:rows] = rows
          h
        end
      end
    end

    def render_home(frame, area)
      return render_error(frame, area, "Loading...") unless @home_data
      return render_error(frame, area, "Error: #{@home_data[:error]}") if @home_data[:error]

      chunks = @tui.layout_split(
        area,
        direction: :vertical,
        constraints: [
          @tui.constraint_length(4), # Stats
          @tui.constraint_fill(1),   # Graph
          @tui.constraint_length(4), # Redis
        ]
      )

      render_stats_section(frame, chunks[0])
      render_chart_section(frame, chunks[1])
      render_redis_info_section(frame, chunks[2])
    end

    def render_status_section(frame, area)
      keys = ["Processes", "Threads", "Busy", "Utilization", "RSS"]
      values = []
      processes = Sidekiq::ProcessSet.new
      workset = Sidekiq::WorkSet.new
      ws = workset.size
      values << (s = processes.size; number_with_delimiter(s))
      values << (x = processes.total_concurrency; number_with_delimiter(x))
      values << number_with_delimiter(ws)
      values << "#{x == 0 ? 0 : ((ws / x.to_f) * 100).round(0)}%"
      values << format_memory(processes.total_rss)

      keys_line = keys.map { |k| k.to_s.ljust(12) }.join("  ")
      values_line = values.map { |v| v.to_s.ljust(12) }.join("  ")

      frame.render_widget(
        @tui.paragraph(
          text: [keys_line, values_line],
          block: @tui.block(title: "Status", borders: [:all])
        ),
        area
      )
    end

    def render_stats_section(frame, area)
      stats = @home_data[:stats]

      keys = ["Processed", "Failed", "Busy", "Enqueued", "Retries", "Scheduled", "Dead"]
      values = [
        stats[:processed],
        stats[:failed],
        stats[:busy],
        stats[:enqueued],
        stats[:retries],
        stats[:scheduled],
        stats[:dead],
      ]

      # Format keys and values with spacing
      keys_line = keys.map { |k| k.to_s.ljust(12) }.join("  ")
      values_line = values.map { |v| v.to_s.ljust(12) }.join("  ")

      frame.render_widget(
        @tui.paragraph(
          text: [keys_line, values_line],
          block: @tui.block(title: "Statistics", borders: [:all])
        ),
        area
      )
    end

    def render_chart_section(frame, area)
      max_value = [@realtime_chart[:deltas][:processed].max, @realtime_chart[:deltas][:failed].max, 1].max
      y_max = [max_value, 5].max

      processed_data = @realtime_chart[:deltas][:processed].each_with_index.map { |value, idx| [idx.to_f, value.to_f] }
      failed_data = @realtime_chart[:deltas][:failed].each_with_index.map { |value, idx| [idx.to_f, value.to_f] }

      datasets = [
        @tui.dataset(
          name: "",
          data: processed_data,
          style: @tui.style(fg: :green),
          marker: :dot,
          graph_type: :line
        ),
        @tui.dataset(
          name: "",
          data: failed_data,
          style: @tui.style(fg: :red),
          marker: :dot,
          graph_type: :line
        )
      ]

      num_labels = 5
      y_labels = (0...num_labels).map do |i|
        value = ((y_max * i) / (num_labels - 1)).round
        value.to_s
      end

      beacon_pulse = (Time.now.to_i % 2 == 0) ? "●" : " "

      chart = @tui.chart(
        datasets: datasets,
        x_axis: @tui.axis(
          bounds: [0.0, 49.0],
          labels: [],
          style: @tui.style(fg: :white)
        ),
        y_axis: @tui.axis(
          bounds: [0.0, y_max.to_f],
          labels: y_labels,
          style: @tui.style(fg: :white)
        ),
        block: @tui.block(
          title: "Dashboard #{beacon_pulse}",
          borders: [:all],
        )
      )

      frame.render_widget(chart, area)
    end

    def render_redis_info_section(frame, area)
      redis_info = @home_data[:redis_info]

      uptime_value = redis_info[:uptime_days] == "N/A" ? "N/A" : "#{redis_info[:uptime_days]} days"

      keys = ["Version", "Uptime", "Connected Clients", "Memory Usage", "Peak Memory"]
      values = [
        redis_info[:version].to_s,
        uptime_value,
        redis_info[:connected_clients].to_s,
        redis_info[:used_memory].to_s,
        redis_info[:peak_memory].to_s
      ]

      # Format keys and values with spacing
      keys_line = keys.map { |k| k.ljust(18) }.join("  ")
      values_line = values.map { |v| v.ljust(18) }.join("  ")

      frame.render_widget(
        @tui.paragraph(
          text: [keys_line, values_line],
          block: @tui.block(title: "Redis Information", borders: [:all])
        ),
        area
      )
    end

    def render_queues(frame, area)
      header = ["Queue", "Size", "Latency"]
      header << "Paused?" if Sidekiq.pro?

      queue_summaries = Sidekiq::Stats.new.queue_summaries.sort_by(&:name)
      @table_row_ids = queue_summaries.map(&:name)

      cells = queue_summaries
        .map { |queue_summary|
          row_cells = [
            queue_summary.name,
            queue_summary.size.to_s,
            number_with_delimiter(queue_summary.latency, { precision: 2 }),
          ]
          row_cells << (queue_summary.paused? ? "✅" : "") if Sidekiq.pro?
          row_cells
        }

      chunks = @tui.layout_split(
        area,
        direction: :vertical,
        constraints: [
          @tui.constraint_length(4), # Stats
          @tui.constraint_fill(1), # Table
        ]
      )

      render_stats_section(frame, chunks[0])
      render_table(frame, chunks[1]) do
        {
          title: "Queues",
          header:,
          widths: header.map.with_index { |_, idx|
            @tui.constraint_length(idx.zero? ? 60 : 10)
          },
          rows: cells.map.with_index { |row_cells, idx|
            @tui.table_row(
              cells: row_cells,
              style: idx.even? ? nil : @tui.style(bg: :dark_gray)
            )
          }
        }
      end
    end

    def render_error(frame, area, message)
      frame.render_widget(
        @tui.paragraph(
          text: message,
          alignment: :center,
          block: @tui.block(title: "Error", borders: [:all], border_style: @tui.style(fg: :red))
        ),
        area
      )
    end

    # TODO Implement I18n delimiter
    def number_with_delimiter(number, options = {})
      precision = options[:precision] || 0
      number.round(precision)
    end

    def format_memory(rss_kb)
      return "0" if rss_kb.nil? || rss_kb == 0

      if rss_kb < 100_000
        "#{number_with_delimiter(rss_kb)} KB"
      elsif rss_kb < 10_000_000
        "#{number_with_delimiter((rss_kb / 1024.0).to_i)} MB"
      else
        "#{number_with_delimiter(rss_kb / (1024.0 * 1024.0), precision: 1)} GB"
      end
    end

    def render_table(frame, area)
      defaults = {
        title: "TableName",
        highlight_symbol: "> ",
        selected_row: @selected_row_index,
        row_highlight_style: @tui.style(fg: :yellow),
      }
      hash = defaults.merge(yield)
      hash[:block] ||= @tui.block(title: hash.delete(:title), borders: :all)
      table = @tui.table(**hash)
      frame.render_widget(table, area)
    end
  end
end

Sidekiq::TUI.new.run
