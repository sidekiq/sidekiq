#!/usr/bin/env ruby

require 'bundler/inline'

gemfile do
  source 'https://gem.coop'
  gem "ratatui_ruby", path: "../ratatui_ruby"
  gem "sidekiq"
end

# https://sr.ht/~kerrick/ratatui_ruby/
# https://git.sr.ht/~kerrick/ratatui_ruby/tree/stable/item/examples/
require "ratatui_ruby"
require "sidekiq/api"

# Suppress Sidekiq logger output to prevent interference with TUI rendering
require "logger"
Sidekiq.default_configuration.logger = Logger.new(IO::NULL)

module Sidekiq
  class TUI
    REFRESH_INTERVAL_SECONDS = 5

    TABS = %w(Home Busy Queues Scheduled Retries Dead).freeze

    def initialize
      @current_tab = "Home"
      @base_style = nil
      @home_data = nil
      @last_refresh = Time.now
    end

    def run
      RatatuiRuby.run do |tui|
        @tui = tui
        @highlight_style = @tui.style(fg: :red, modifiers: [:underlined])
        @hotkey_style = @tui.style(modifiers: [:bold, :underlined])

        refresh_data

        loop do
          refresh_data if should_refresh?
          render
          break if handle_input == :quit
        end
      end
    end

    def render
      @tui.draw do |frame|
        main_area, controls_area = @tui.layout_split(
          frame.area,
          direction: :vertical,
          constraints: [
            @tui.constraint_fill(1),
            @tui.constraint_length(4),
          ]
        )

        # Split main area into tabs and content
        tabs_area, content_area = @tui.layout_split(
          main_area,
          direction: :vertical,
          constraints: [
            @tui.constraint_length(3),
            @tui.constraint_fill(1),
          ]
        )

        tabs = @tui.tabs(
          titles: TABS,
          selected_index: selected_tab_index,
          block: @tui.block(title: Sidekiq::NAME, borders: [:all], title_style: @tui.style(fg: :red, modifiers: [:bold])),
          divider: " | ",
          highlight_style: @highlight_style,
          style: @base_style,
        )
        frame.render_widget(tabs, tabs_area)

        render_content_area(frame, content_area)
        render_controls(frame, controls_area, tabs.width)
      end
    end

    def render_content_area(frame, content_area)
      case @current_tab
      when "Home"
        render_home(frame, content_area)
      else
        frame.render_widget(
          @tui.paragraph(
            text: "Tab '#{@current_tab}' - Coming soon",
            alignment: :center,
            block: @tui.block(title: @current_tab, borders: [:all])
          ),
          content_area
        )
      end
    end

    def render_controls(frame, area, current_width)
      controls = @tui.block(
        title: "Controls",
        borders: [:all],
        children: [
          @tui.paragraph(
            text: [
              @tui.text_line(spans: [
                @tui.text_span(content: "←/→", style: @hotkey_style),
                @tui.text_span(content: ": Select Tab  "),
                @tui.text_span(content: "q", style: @hotkey_style),
                @tui.text_span(content: ": Quit"),
              ]),
              # @tui.text_line(spans: [
              #   @tui.text_span(content: "d", style: @hotkey_style),
              #   @tui.text_span(content: ": Divider (#{@dividers[@divider_index]})  "),
              #   @tui.text_span(content: "s", style: @hotkey_style),
              #   @tui.text_span(content: ": Highlight (#{@highlight_styles[@highlight_style_index][:name]})  "),
              #   @tui.text_span(content: "b", style: @hotkey_style),
              #   @tui.text_span(content: ": Base Style (#{@base_styles[@base_style_index][:name]})  "),
              # ]),
              @tui.text_line(spans: [
                @tui.text_span(content: "Redis: #{redis_url}"),
              ]),
            ]
          ),
        ]
      )
      frame.render_widget(controls, area)
    end

    def handle_input
      case @tui.poll_event
      in { type: :key, code: "q" } | { type: :key, code: "c", modifiers: ["ctrl"] }
        :quit
      in type: :key, code: "right"
        old_tab = @current_tab
        @current_tab = next_tab
        refresh_data if switching_to_tab?("Home", old_tab)
      in type: :key, code: "left"
        old_tab = @current_tab
        @current_tab = previous_tab
        refresh_data if switching_to_tab?("Home", old_tab)
      else
        # Ignore other events
      end
    end

    def redis_url
      Sidekiq.redis do |conn|
        conn.config.server_url
      end
    rescue
      "N/A"
    end

    def should_refresh?
      Time.now - @last_refresh >= REFRESH_INTERVAL_SECONDS
    end

    def selected_tab_index
      TABS.index(@current_tab) || 0
    end

    def next_tab
      current_index = selected_tab_index
      TABS[(current_index + 1) % TABS.size]
    end

    def previous_tab
      current_index = selected_tab_index
      TABS[(current_index - 1) % TABS.size]
    end

    def current_tab?(tab_name)
      @current_tab == tab_name
    end

    def switching_to_tab?(tab_name, old_tab)
      current_tab?(tab_name) && old_tab != tab_name
    end

    def refresh_data
      return unless current_tab?("Home")

      begin
        stats = Sidekiq::Stats.new
        redis_info = Sidekiq.default_configuration.redis_info

        @home_data = {
          stats: {
            processed: stats.processed,
            failed: stats.failed,
            busy: stats.workers_size,
            enqueued: stats.enqueued,
            retries: stats.retry_size,
            scheduled: stats.scheduled_size,
            dead: stats.dead_size,
          },
          redis_info: {
            version: redis_info["redis_version"] || "N/A",
            uptime_days: redis_info["uptime_in_days"] || "N/A",
            connected_clients: redis_info["connected_clients"] || "N/A",
            used_memory: redis_info["used_memory_human"] || "N/A",
            peak_memory: redis_info["used_memory_peak_human"] || "N/A"
          }
        }
        @last_refresh = Time.now
      rescue => e
        @home_data = { error: e.message }
      end
    end

    def render_home(frame, area)
      return render_error(frame, area, "Loading...") unless @home_data
      return render_error(frame, area, "Error: #{@home_data[:error]}") if @home_data[:error]

      chunks = @tui.layout_split(
        area,
        direction: :vertical,
        constraints: [
          @tui.constraint_length(4), # Stats
          @tui.constraint_fill(1),   # Graph
          @tui.constraint_length(4), # Redis
        ]
      )

      render_stats_section(frame, chunks[0])
      frame.render_widget(
        @tui.paragraph(
          text: "Graph coming soon",
          alignment: :center,
          block: @tui.block(title: "Dashboard", borders: [:all])
        ),
        chunks[1]
      )
      render_redis_info_section(frame, chunks[2])
    end

    def render_stats_section(frame, area)
      stats = @home_data[:stats]

      keys = ["Processed", "Failed", "Busy", "Enqueued", "Retries", "Scheduled", "Dead"]
      values = [
        stats[:processed].to_s,
        stats[:failed].to_s,
        stats[:busy].to_s,
        stats[:enqueued].to_s,
        stats[:retries].to_s,
        stats[:scheduled].to_s,
        stats[:dead].to_s
      ]

      # Format keys and values with spacing
      keys_line = keys.map { |k| k.ljust(12) }.join("  ")
      values_line = values.map { |v| v.ljust(12) }.join("  ")

      frame.render_widget(
        @tui.paragraph(
          text: [keys_line, values_line],
          block: @tui.block(title: "Statistics", borders: [:all])
        ),
        area
      )
    end

    def render_redis_info_section(frame, area)
      redis_info = @home_data[:redis_info]

      uptime_value = redis_info[:uptime_days] == "N/A" ? "N/A" : "#{redis_info[:uptime_days]} days"

      keys = ["Version", "Uptime", "Connected Clients", "Memory Usage", "Peak Memory"]
      values = [
        redis_info[:version].to_s,
        uptime_value,
        redis_info[:connected_clients].to_s,
        redis_info[:used_memory].to_s,
        redis_info[:peak_memory].to_s
      ]

      # Format keys and values with spacing
      keys_line = keys.map { |k| k.ljust(18) }.join("  ")
      values_line = values.map { |v| v.ljust(18) }.join("  ")

      frame.render_widget(
        @tui.paragraph(
          text: [keys_line, values_line],
          block: @tui.block(title: "Redis Information", borders: [:all])
        ),
        area
      )
    end

    def render_error(frame, area, message)
      frame.render_widget(
        @tui.paragraph(
          text: message,
          alignment: :center,
          block: @tui.block(title: "Error", borders: [:all], border_style: @tui.style(fg: :red))
        ),
        area
      )
    end

  end
end

Sidekiq::TUI.new.run