#!/usr/bin/env ruby

require 'bundler/inline'

gemfile do
  source 'https://gem.coop'
  gem "ratatui_ruby", path: "../ratatui_ruby"
  gem "sidekiq"
end

# https://sr.ht/~kerrick/ratatui_ruby/
# https://git.sr.ht/~kerrick/ratatui_ruby/tree/stable/item/examples/
require "ratatui_ruby"
require "sidekiq/api"

module Sidekiq
  class TUI
    REFRESH_INTERVAL_SECONDS = 5

    TABS = %w(Home Busy Queues Scheduled Retries Dead).freeze

    def initialize
      @current_tab = "Home"
      @base_style = nil
      @home_data = nil
      @last_refresh = Time.now
    end

    def run
      RatatuiRuby.run do |tui|
        @tui = tui
        @highlight_style = @tui.style(fg: :red, modifiers: [:underlined])
        @hotkey_style = @tui.style(modifiers: [:bold, :underlined])

        refresh_data

        loop do
          refresh_data if should_refresh?
          render
          break if handle_input == :quit
        end
      end
    end

    def render
      @tui.draw do |frame|
        main_area, controls_area = @tui.layout_split(
          frame.area,
          direction: :vertical,
          constraints: [
            @tui.constraint_fill(1),
            @tui.constraint_length(5),
          ]
        )

        # Split main area into tabs and content
        tabs_area, content_area = @tui.layout_split(
          main_area,
          direction: :vertical,
          constraints: [
            @tui.constraint_length(3),
            @tui.constraint_fill(1),
          ]
        )

        tabs = @tui.tabs(
          titles: TABS,
          selected_index: selected_tab_index,
          block: @tui.block(title: "SidekiqTUI", borders: [:all], title_style: @tui.style(fg: :red, modifiers: [:bold])),
          divider: " | ",
          highlight_style: @highlight_style,
          style: @base_style,
        )
        frame.render_widget(tabs, tabs_area)

        case @current_tab
        when "Home"
          render_home(frame, content_area)
        else
          frame.render_widget(
            @tui.paragraph(
              text: "Tab '#{@current_tab}' - Coming soon",
              alignment: :center,
              block: @tui.block(title: @current_tab, borders: [:all])
            ),
            content_area
          )
        end

        render_controls(frame, controls_area, tabs.width)
      end
    end

    private def render_controls(frame, area, current_width)
      controls = @tui.block(
        title: "Controls",
        borders: [:all],
        children: [
          @tui.paragraph(
            text: [
              @tui.text_line(spans: [
                @tui.text_span(content: "←/→", style: @hotkey_style),
                @tui.text_span(content: ": Select Tab  "),
                @tui.text_span(content: "q", style: @hotkey_style),
                @tui.text_span(content: ": Quit"),
              ]),
              # @tui.text_line(spans: [
              #   @tui.text_span(content: "d", style: @hotkey_style),
              #   @tui.text_span(content: ": Divider (#{@dividers[@divider_index]})  "),
              #   @tui.text_span(content: "s", style: @hotkey_style),
              #   @tui.text_span(content: ": Highlight (#{@highlight_styles[@highlight_style_index][:name]})  "),
              #   @tui.text_span(content: "b", style: @hotkey_style),
              #   @tui.text_span(content: ": Base Style (#{@base_styles[@base_style_index][:name]})  "),
              # ]),
              @tui.text_line(spans: [
                @tui.text_span(content: "Redis: #{redis_url}"),
              ]),
            ]
          ),
        ]
      )
      frame.render_widget(controls, area)
    end

    def handle_input
      case @tui.poll_event
      in { type: :key, code: "q" } | { type: :key, code: "c", modifiers: ["ctrl"] }
        :quit
      in type: :key, code: "right"
        old_tab = @current_tab
        @current_tab = next_tab
        refresh_data if switching_to_tab?("Home", old_tab)
      in type: :key, code: "left"
        old_tab = @current_tab
        @current_tab = previous_tab
        refresh_data if switching_to_tab?("Home", old_tab)
      else
        # Ignore other events
      end
    end

    def redis_url
      Sidekiq.redis do |conn|
        conn.config.server_url
      end
    rescue
      "N/A"
    end

    def should_refresh?
      Time.now - @last_refresh >= REFRESH_INTERVAL_SECONDS
    end

    def selected_tab_index
      TABS.index(@current_tab) || 0
    end

    def next_tab
      current_index = selected_tab_index
      TABS[(current_index + 1) % TABS.size]
    end

    def previous_tab
      current_index = selected_tab_index
      TABS[(current_index - 1) % TABS.size]
    end

    def current_tab?(tab_name)
      @current_tab == tab_name
    end

    def switching_to_tab?(tab_name, old_tab)
      current_tab?(tab_name) && old_tab != tab_name
    end

    def refresh_data
      return unless current_tab?("Home")

      begin
        stats = Sidekiq::Stats.new
        redis_info = Sidekiq.default_configuration.redis_info

        @home_data = {
          stats: {
            processed: stats.processed,
            failed: stats.failed,
            busy: stats.workers_size,
            enqueued: stats.enqueued,
            retries: stats.retry_size,
            scheduled: stats.scheduled_size,
            dead: stats.dead_size,
          },
          redis_info: {
            version: redis_info["redis_version"] || "N/A",
            uptime_days: redis_info["uptime_in_days"] || "N/A",
            connected_clients: redis_info["connected_clients"] || "N/A",
            used_memory: redis_info["used_memory_human"] || "N/A",
            peak_memory: redis_info["used_memory_peak_human"] || "N/A"
          }
        }
        @last_refresh = Time.now
      rescue => e
        @home_data = { error: e.message }
      end
    end

    def render_home(frame, area)
      return render_error(frame, area, "Loading...") unless @home_data
      return render_error(frame, area, "Error: #{@home_data[:error]}") if @home_data[:error]

      chunks = @tui.layout_split(
        area,
        direction: :vertical,
        constraints: [
          @tui.constraint_length(12), # Stats section
          @tui.constraint_fill(1),    # Redis info section
        ]
      )

      render_stats_section(frame, chunks[0])
      render_redis_info_section(frame, chunks[1])
    end

    def render_stats_section(frame, area)
      stats = @home_data[:stats]

      rows = [
        ["Processed", stats[:processed].to_s],
        ["Failed", stats[:failed].to_s],
        ["Busy", stats[:busy].to_s],
        ["Enqueued", stats[:enqueued].to_s],
        ["Retries", stats[:retries].to_s],
        ["Scheduled", stats[:scheduled].to_s],
        ["Dead", stats[:dead].to_s],
      ]

      frame.render_widget(
        @tui.table(
          header: ["Metric", "Value"],
          rows: rows,
          widths: [
            @tui.constraint_percentage(50),
            @tui.constraint_percentage(50)
          ],
          block: @tui.block(title: "Statistics", borders: [:all])
        ),
        area
      )
    end

    def render_redis_info_section(frame, area)
      redis_info = @home_data[:redis_info]

      rows = [
        ["Version", redis_info[:version].to_s],
        ["Uptime", redis_info[:uptime_days] == "N/A" ? "N/A" : "#{redis_info[:uptime_days]} days"],
        ["Connected Clients", redis_info[:connected_clients].to_s],
        ["Memory Usage", redis_info[:used_memory].to_s],
        ["Peak Memory", redis_info[:peak_memory].to_s],
      ]

      frame.render_widget(
        @tui.table(
          header: ["Property", "Value"],
          rows: rows,
          widths: [
            @tui.constraint_percentage(50),
            @tui.constraint_percentage(50)
          ],
          block: @tui.block(title: "Redis Information", borders: [:all])
        ),
        area
      )
    end

    def render_error(frame, area, message)
      frame.render_widget(
        @tui.paragraph(
          text: message,
          alignment: :center,
          block: @tui.block(title: "Error", borders: [:all], border_style: @tui.style(fg: :red))
        ),
        area
      )
    end

  end
end

Sidekiq::TUI.new.run